---
layout: '[layout]'
title: 发布-订阅 观察者模式
date: 2018-06-05 17:22:08
tags: 观察者模式的两种实现方式
---
>观察者模式:
    定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知
>写法1:
```
    // 添加事件的方法，该方法接收两个参数，一个是要添加的事件的类型，一个是这个事件的回调函数名。
    // 调用的时候会首先遍历window.onMessag这个数组，看看这个类型的方法是否已经存在，如果已经存在则添加到该数组，如果不存在则先创建一个数组然后添加。
    window.onMessage = function(name,callback){
        //此时内部window.onMessage 为一个数组，成员为callback，如果window.onMessage[name] 不存在,则创建一个空数组
        var msgs = window.onMessage[name] = window.onMessage[name] || [];
        msgs.push(callback); //浅拷贝，push后window.onMessage[name]的值也会改变(之前没注意到这层，导致半天没走通)
    };

    window.sendMessage = function(name,param){
        // msgs  = 数组window.onMessage[name],随后遍历改数组,调用window.onMessage[name]子数组里面的函数也即是一或多个callback(param);
        var msgs = window.onMessage[name] || [];
        msgs.forEach(function(msg){
            msg(param);
        })
    };
    //window.onMessage 监听事件
    //window.sendMessage 发布事件
```

```
window.onMessage = function(name,callback){
    window.onMessage[name] = window.onMessage[name] || [];
    var msgs = Array.prototype.slice.call(window.onMessage[name]);  //此时使用的深拷贝则无法实现 , 当然
    msgs.push(callback);
};

window.sendMessage = function(name,param){
    console.log(window.onMessage[name],23456787654);
    var msgs = window.onMessage[name] || [];
    msgs.forEach(function(msg){
        msg(param);
    })
};

```
>实现2：参考自https://www.cnblogs.com/LuckyWinty/p/5796190.html
    题目实现以下功能
    ```
    // 测试1
    Event.on('test', function (result) {
        console.log(result);
    });
    Event.on('test', function () {
        console.log('test');
    });
    Event.emit('test', 'hello world'); // 输出 'hello world' 和 'test'
    ```

    代码:
    ```
   var Event = {
       // 通过on接口监听事件eventName
       // 如果事件eventName被触发，则执行callback回调函数
       on: function (eventName, callback) {
           //我的代码
           if(!this.handles){
                this.handles={};
           }
          if(!this.handles[eventName]){
               this.handles[eventName]=[];
          }
          this.handles[eventName].push(callback);
       },
       // 触发事件 eventName
       emit: function (eventName) {
           //你的代码
          if(this.handles[arguments[0]]){
              for(var i=0;i<this.handles[arguments[0]].length;i++){
                  this.handles[arguments[0]][i](arguments[1]);
              }
          }
       }
   };
    ```
